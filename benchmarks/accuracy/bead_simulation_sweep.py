"""Bead simulation sweep scaffolding for accuracy benchmarking."""

from __future__ import annotations

import itertools
import json
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Iterable, Mapping, Sequence

import numpy as np

from benchmarks.speed import log_utils

_DEFAULT_SWEEP_ROOT = Path(__file__).resolve().parent / "sweeps"


@dataclass
class ParameterSet:
    """Configuration describing a grid of simulation parameters."""

    name: str
    parameters: Mapping[str, Sequence[Any]]
    image_shape: Sequence[int] = (64, 64, 1)

    def combinations(self) -> list[dict[str, Any]]:
        """Return all parameter combinations expanded from the grid."""

        param_names = list(self.parameters.keys())
        values = [list(self.parameters[name]) for name in param_names]
        combos: list[dict[str, Any]] = []
        for combination in itertools.product(*values):
            combos.append(dict(zip(param_names, combination)))
        return combos


@dataclass
class SweepArtifact:
    """Paths and metadata generated by a simulation sweep."""

    sweep_name: str
    sweep_dir: Path
    images_path: Path
    metadata_path: Path
    metadata: dict[str, Any] = field(default_factory=dict)


class BeadSimulationSweep:
    """Generate placeholder bead simulation sweeps and metadata."""

    def __init__(
        self,
        sweep_name: str,
        parameter_sets: Sequence[ParameterSet] | None = None,
        *,
        sweep_root: Path | str = _DEFAULT_SWEEP_ROOT,
    ) -> None:
        self.sweep_name = self._sanitize_name(sweep_name)
        self.parameter_sets = list(parameter_sets or [default_parameter_set()])
        self.sweep_root = Path(sweep_root)

    def generate(self, overwrite: bool = False) -> SweepArtifact:
        """Create the sweep outputs on disk and return their locations."""

        sweep_dir = self.sweep_root / self.sweep_name
        sweep_dir.mkdir(parents=True, exist_ok=True)

        images_path = sweep_dir / "images.npz"
        metadata_path = sweep_dir / "metadata.json"
        if not overwrite and (images_path.exists() or metadata_path.exists()):
            raise FileExistsError(
                f"Sweep artifacts already exist in '{sweep_dir}'. Set overwrite=True to replace them."
            )

        images = {}
        parameter_metadata = []
        for param_set in self.parameter_sets:
            set_name = self._sanitize_name(param_set.name)
            combinations = param_set.combinations()
            combination_metadata = []
            for index, combo in enumerate(combinations):
                image_shape = tuple(combo.get("image_shape", param_set.image_shape))
                self._validate_image_shape(image_shape)
                image_key = f"{set_name}__{index:04d}"
                images[image_key] = self._simulate_placeholder(image_shape, combo)
                combination_metadata.append(
                    {
                        "key": image_key,
                        "values": self._ensure_json_serializable(combo),
                        "image_shape": list(image_shape),
                    }
                )
            parameter_metadata.append(
                {
                    "name": set_name,
                    "parameters": self._ensure_json_serializable({
                        key: list(values) for key, values in param_set.parameters.items()
                    }),
                    "combinations": combination_metadata,
                }
            )

        np.savez(images_path, **images)

        system_id, timestamp, system_metadata = log_utils.collect_system_metadata()
        created_at = datetime.now(timezone.utc).isoformat()
        metadata = {
            "sweep_name": self.sweep_name,
            "created_at": created_at,
            "image_file": images_path.name,
            "total_images": len(images),
            "parameter_sets": parameter_metadata,
            "system": {
                "id": system_id,
                "timestamp": timestamp,
                "metadata": system_metadata,
            },
        }

        metadata_path.write_text(json.dumps(metadata, indent=2))

        return SweepArtifact(
            sweep_name=self.sweep_name,
            sweep_dir=sweep_dir,
            images_path=images_path,
            metadata_path=metadata_path,
            metadata=metadata,
        )

    @staticmethod
    def _simulate_placeholder(image_shape: tuple[int, int, int], combo: Mapping[str, Any]) -> np.ndarray:
        """Return a placeholder float64 image for the given *image_shape*.

        The placeholder uses the ``background`` parameter when present to fill
        the array so that downstream consumers can differentiate sweeps even
        before the real simulator is wired in.
        """

        background = float(combo.get("background", 0.0))
        return np.full(image_shape, background, dtype=np.float64)

    @staticmethod
    def _sanitize_name(name: str) -> str:
        safe = [c if c.isalnum() or c in {"-", "_"} else "-" for c in name]
        sanitized = "".join(safe).strip("-")
        return sanitized or "sweep"

    @staticmethod
    def _ensure_json_serializable(value: Any) -> Any:
        if value is None or isinstance(value, (str, int, float, bool)):
            return value
        if isinstance(value, dict):
            return {str(k): BeadSimulationSweep._ensure_json_serializable(v) for k, v in value.items()}
        if isinstance(value, (list, tuple, set)):
            return [BeadSimulationSweep._ensure_json_serializable(v) for v in value]
        if hasattr(value, "tolist"):
            try:
                return value.tolist()
            except Exception:  # noqa: BLE001
                pass
        try:
            return json.loads(json.dumps(value))
        except Exception:  # noqa: BLE001
            return repr(value)

    @staticmethod
    def _validate_image_shape(image_shape: Iterable[int]) -> None:
        shape = tuple(int(dim) for dim in image_shape)
        if len(shape) != 3:
            raise ValueError(f"Image shape must be a 3-tuple (H, W, 1); received {shape}.")
        if shape[2] != 1:
            raise ValueError(f"Final image dimension must be 1; received {shape}.")

    @staticmethod
    def default_parameter_set() -> ParameterSet:
        return default_parameter_set()


def default_parameter_set() -> ParameterSet:
    """Return the default placeholder parameter set."""

    return ParameterSet(
        name="default",
        parameters={
            "x_offset": [-1.0, 1.0],
            "y_offset": [-1.0, 1.0],
            "z_offset": [-1.0, 1.0],
            "background": [0.0, 10.0],
            "seed": [123, 456],
        },
        image_shape=(64, 64, 1),
    )


__all__ = ["BeadSimulationSweep", "ParameterSet", "SweepArtifact", "default_parameter_set"]
